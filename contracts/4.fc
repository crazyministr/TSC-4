{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

builder _store_builder_ref(builder to, builder what) asm(what to) "STBREF";


(builder) rec(tuple t, slice string) {
  builder b = begin_cell();

  repeat (string.slice_bits() / 8) {
    int ch = string~load_uint(8);
    b = b.store_uint(t.at(ch), 8);
  }

  if (string.slice_refs()) {
    builder res = rec(t, string.preload_ref().begin_parse());
    return b._store_builder_ref(res);
  }

  return b;
}

forall X -> (tuple) to_tuple (X x) asm "NOP";

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  tuple t = to_tuple([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]);
  int i = 15;
  repeat (50) { t~tpush(i); i += 1;}
  repeat (26) { t~tpush(((i - 65 + shift) % 26) + 65); i += 1; }
  repeat (6) { t~tpush(i); i += 1; }
  repeat (26) { t~tpush(((i - 97 + shift) % 26) + 97); i += 1; }
  repeat (95) { t~tpush(i); i += 1; }

  slice string = text.begin_parse();
  string~skip_bits(32);
  return begin_cell()
    .store_uint(0, 32)
    .store_builder(rec(t, string))
  .end_cell();
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  tuple t = to_tuple([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]);
  int i = 15;
  repeat (50) { t~tpush(i); i += 1;}
  repeat (26) { t~tpush(((i - 65 - shift) % 26) + 65); i += 1; }
  repeat (6) { t~tpush(i); i += 1; }
  repeat (26) { t~tpush(((i - 97 - shift) % 26) + 97); i += 1; }
  repeat (95) { t~tpush(i); i += 1; }
  slice string = text.begin_parse();
  string~skip_bits(32);
  return begin_cell()
    .store_uint(0, 32)
    .store_builder(rec(t, string))
    .end_cell();
}
