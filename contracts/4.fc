{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

builder _store_builder_ref(builder to, builder what) asm(what to) "STBREF";


(builder) rec(int shift, slice string) {
  {-
  int n = 0;
  tuple stack = null();
  builder b = begin_cell();
  do {
    
    repeat (string.slice_bits() >> 3) {
      int ch = string~load_uint(8);
      if ((ch >= 97) & (ch <= 122)) {  ;; a-z
        ch = ((ch - 97 + shift) % 26) + 97;
      } elseif ((ch >= 65) & (ch <= 90)) {  ;; A-Z
        ch = ((ch - 65 + shift) % 26) + 65;
      }
      if (b.builder_bits() + 8 < 1024) {
        b = b.store_uint(ch, 8);
      } else {
        stack = cons(b, stack);
        n += 1;
        b = begin_cell().store_uint(ch, 8);
      }
      
    }

    int f = -1;
    if (string.slice_refs()) {
      string = string.preload_ref().begin_parse();
    } else {
      f = 0;
    }

  } until (~ f);

  repeat (n) {
    (builder p, stack) = uncons(stack);
    b = p._store_builder_ref(b);
  }
-}
  builder b = begin_cell();
  ;; repeat (string.slice_bits() / 64) {
  ;;   int ch64 = string~load_uint(64);
  ;;   int new_ch64 = 0;
  ;;   int i = 7;
  ;;   repeat (8) {
  ;;     int ch = (ch64 >> (8 * i)) & 0xff;
  ;;     if ((ch >= 97) & (ch <= 122)) {  ;; a-z
  ;;       ch = ((ch - 97 + shift) % 26) + 97;
  ;;     } elseif ((ch >= 65) & (ch <= 90)) {  ;; A-Z
  ;;       ch = ((ch - 65 + shift) % 26) + 65;
  ;;     }
  ;;     new_ch64 = (new_ch64 << 8) | ch;
  ;;     ;; ch = ch << (8 * i);
  ;;     ;; ch64 = (ch64 & (~ (0xff << (8 * i)))) | ch;
  ;;     i -= 1;
  ;;   }
  ;;   b = b.store_uint(new_ch64, 64);
  ;; }

  repeat (string.slice_bits() / 8) {
    int ch = string~load_uint(8);
    if ((ch > 64) & (ch < 91)) {  ;; A-Z
      ch = ((ch - 65 + shift) % 26) + 65;
    } elseif ((ch > 96) & (ch < 123)) {  ;; a-z
      ch = ((ch - 97 + shift) % 26) + 97;
    }
    b = b.store_uint(ch, 8);
  }

  if (string.slice_refs()) {
    builder res = rec(shift, string.preload_ref().begin_parse());
    ;; if (b.builder_bits() + res.builder_bits() < 1024) {
    ;;   return b.store_builder(res);
    ;; }
    return b._store_builder_ref(res);
  }

  return b;
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  slice string = text.begin_parse();
  string~skip_bits(32);
  return begin_cell()
    .store_uint(0, 32)
    .store_builder(rec(shift, string))
  .end_cell();
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  slice string = text.begin_parse();
  string~skip_bits(32);
  return begin_cell()
    .store_uint(0, 32)
    .store_builder(rec(- shift, string))
    .end_cell();
}
